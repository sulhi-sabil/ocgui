# Agentic QE Testing Skill

## Description
Quality engineering approach using AI agents for comprehensive testing automation.

## When to Use
- Creating test strategies
- Implementing automated tests
- Performing security audits
- Conducting performance testing
- Managing releases

## QE Agent Fleet

### 1. QE Quality Analyzer
**Responsibility**: Logic and maintainability analysis
**Capabilities**:
- Code quality assessment
- Maintainability scoring
- Technical debt identification
- Best practice compliance

### 2. QE Security Scanner
**Responsibility**: Security risk detection
**Capabilities**:
- Vulnerability scanning
- Dependency audit
- Secret detection
- OWASP compliance

### 3. QE Performance Tester
**Responsibility**: Performance issue identification
**Capabilities**:
- Load testing
- Response time analysis
- Resource utilization
- Bottleneck detection

### 4. QE Coverage Analyzer
**Responsibility**: Test coverage analysis
**Capabilities**:
- Coverage reporting
- Gap identification
- Risk assessment
- Prioritization

## Testing Strategies

### Parallel Fleet Execution
```
Code Review Fleet:
├── QE Quality Analyzer (logic, maintainability)
├── QE Security Scanner (security risks)
├── QE Performance Tester (performance issues)
└── QE Coverage Analyzer (test coverage)
```

### Mobile Testing Fleet
```
Mobile Fleet:
├── QE Test Executor (cross-platform execution)
├── QE Performance Tester (mobile performance)
└── QE Visual Tester (screen size validation)
```

## Test Generation Principles

### Agentic QE Goals
- **10x improvement** in test effectiveness (not just speed)
- **Self-healing** test suites that evolve with the product
- **Autonomous** quality orchestration with human oversight

### Classical QE Achievements
- 60% faster test generation with AI assistance
- 85% reduction in test maintenance through smart automation
- 4x improvement in defect detection with exploratory agents

## Implementation Workflow

1. **Analyze Requirements**
   - Understand feature requirements
   - Identify critical paths
   - Determine risk areas

2. **Generate Test Cases**
   - Create positive test cases
   - Create negative test cases
   - Add edge cases
   - Include boundary testing

3. **Execute Tests**
   - Run unit tests
   - Run integration tests
   - Run E2E tests
   - Perform exploratory testing

4. **Report & Fix**
   - Document findings
   - Prioritize issues
   - Track fixes
   - Verify resolutions

## Metrics
- Test coverage percentage
- Defect detection rate
- Test execution time
- Maintenance effort reduction
